<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="style.css">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link type="text/css" rel="stylesheet" href="normalize.css">
<title>Tribute Page</title>

<div class="main" id="main">
  <h1 class="title" id="title">Quicksort</h1>

  <div class="img-div" id="img-div">
    <img class="img-div__img" id="image" src="photo.jpg" width="500" height="333" alt="Visualization">
    <div class="img-div__caption" id="img-caption">Visualization</div>
  </div>

  <div class="info" id="tribute-info">
    <section class="info__chsticks" id="characteristics">
      <h2 class="info__chsticks-hdr">Characteristics</h2>
      <ul class="info__chsticks-list">
        <li>Developed by British computer scientist Tony Hoare in 1959 and published in 1961.</li>
        <li>It partitions the input array to two sub-arrays, then sorts each subarray recursively.</li>
        <li>When implemented well, it can be about two or three times faster than its main competitors, merge sort and heapsort.</li>
        <li>In efficient implementations it is not a stable sort.</li>
        <li>It is a divide and conquer algorithm.</li>
        <li>Can operate in-place on an array, requiring small additional amounts of memory to perform the sorting.</li>
        <li>Gained widespread adoption, appearing, for example, in Unix as the default library sort subroutine. Hence, it lent its name to the C standard library subroutine qsort and in the reference implementation of Java.</li>
        <li>The pivot selection and partitioning steps can be done in several different ways, the choice of specific implementation schemes greatly affects the algorithm's performance.</li>
        <li>On average, quicksort performs only about 39% worse than in its best case. In this sense, it is closer to the best case than the worst case. This fast average runtime is another reason for quicksort's practical dominance over other sorting algorithms.</li>
      </ul>
    </section>
    <section class="info__complexity" id="complexity">
      <h3 class="info__complexity-hdr">Time and space complexity</h3>
      <ul class="info__complexity-list">
        <li>Worst case: O(n^2) - this behavior is rare</li>      
        <li>Average case: O(n log(n))</li>
        <li>Best case - Simple partition: O(n log(n))</li>
        <li>Best case - Three-way partition and equal keys: O(n)</li>
        <li>Worst case space - Auxiliary (naive): O(n)</li>
        <li>Worst case space - Auxiliary (Sedgewick 1978): O(log(n))</li>
      </ul>
    </section>
  </div>
  <blockquote><i>“There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.”</i> - Tony Hoare</blockquote>
  <div>
    <p>More information on <a class="tribute-link" id="tribute-link" href="https://en.wikipedia.org/wiki/Quicksort" target="_blank">Wikipedia</a></p>
    <p>Image source: Simpsons contributor on Wikimedia Commons</p>
  </div>
</div>
<script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</html>